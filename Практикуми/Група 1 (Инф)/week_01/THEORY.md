## Преход към C++. Разлики и новости.

### Препроцесорни директиви
---
Това е код, предшеставн от символ '#'. Преди процесът на компилация на вашия код, препроцесорът сканира всички ваши файлове и търси подобни директиви, 
за да ги изпълни. Това означа, че тези редове код се изпълняват **преди процесa на компилация**!  

**Как пишем такива директиви?**
Пишат се само на един ред. При срещанто на знак за нов ред препроцесорът спира да счита кода като част от досега прочетената директива. Ако искаме да пишем
на няколко реда използваме **line-break** символа '\'

~~~.cpp
Няколко пример: (Дефиниция на макорси)

#define HEIGHT 10
#define max(a,b) \  // line-break
((a)>(b)?(a):(b))

#undef max     
#undef HEIGHT  // от тук надолу няма да се разпознават като макроси
~~~

### Различните препроцесорни директиви (Това е малка извадка)
- define   - приема <identifier><replace_value>. Заменя **identifier** с **replace_value**;
- ifdef   - приема **идентифиатор**. Проверява дали **идентификаторът** е дефиниран и изпълнява блока;
- ifndef  - обратното на ifdef;
- if/elif - приема условие което трябва да се изпълни с дадени макроси
- endif   - **всеки if/ifdef/ifndef трябва да бъде затворен с endif**
- error   - приключва компилационния процес при изпълнение
- include - при срещането на тази директива съдържанието на header файлва се замества на мястото на диркетивата

**Важно**  
Можем да добавим header файл по два начина
~~~.cpp
#include <header_name.hpp> // претърсва специално място опеределено от компилатора за библиотеки като стандартната на C++.  
#include "header_name.hpp" // претърсва "имплементационно", като най-често взима сегашната директория като root за претърсването по нататък. 
~~~

### Добавяне на header файлове от стандартната библиотека
---

Вече ще използваме следния начин за добавяне на header файлове от стандатната библиотека (**старите варианти също ще работят**)
~~~.cpp
#include <cmath>     // вместо math.h
#include <cstring>   // вместо string.h
#include <cctype>    // вместо ctype.h 
~~~

### Наименовани пространства
---

В **C** бяхме разгледали така наречените **scope-ове** или както вече ще ги наричаме ненаименувани блокове код. При тях ако предефинираме име на променлива тя се скриваше (получаваше се така нареченият shadowing ефект). Наименованите пространства обаче ни дават възможността да преизползваме едни и същи имена на променливи като просто се обърнем към наименуваният блок от код където, тя е дефинирана. Това се случва с така нареченият scope оператор "::" 

В един наименуван блок можем да сложим много неща - функции, класове, структури, променливи и т.н, но това ще разгледаме в последствие

~~~.cpp
using namespace std;

namespace mine
{
  int my_number = 1;
}

int main(void)
{
    int my_number = 2;
    cout << my_number;       // принтира 2
    cout << mine::my_number; // принтира 1
}
~~~

### Вход/Изход
---

В C++ разполагаме със специална библиотека за обработка на вход и изход.   

Изходът ни тук е буфериран, което значи при извеждане във файл/на конзолата и т.н писаното от нас се натрупва в буфер, докато той не бъде изпразнен и съответно изведен в пространството където пишете. Като затова има специални функции като flush или ако използваме терминиращия символ endl.  

За да достъпим библиотеката за I/O, трябва да добавим следния header файл - iostream (Input Output Stream)  

**Много важно**  
Тъй като функциите и класовете, които ще използваме са част от стандартната библиотека, ще трябва да използваме абривиетурата std за достъп до тях и оператор за принадлежност "::". Това е така, тъй като тези фунцкии и по-нататък класове са декларирани и дефинирани в наименованото пространство **std**.

~~~.cpp
// Пример за вход
#include <iostream>

int main(void)
{
    int a;
    double b;
    char str[10];

    // Четем с оператор >>
    // Като той изрично пропуска празното пространство и може да чете разнотипни променливи
    std::cin >> a >> b; 

    std::cin >> str;           // ВНИМАВАЙТЕ, няма защита от писане в несъществуваща памет, това ще счупи потока при преливане!!!
    std::cin.getline(str,10);  // Това гарантира безопасно четене. Спира на първият знак ' ' или до края на буфера
}

// Пример за изход
#include <iostream>

int main(void)
{
    int age = 10;
    char name[] = "Slim Shady";

    std::cout << "My name is: " << name << '\n' << "My age is: " << age << std::endl; // endl изчиства буфера

    // Ако искате само нов ред пишете '\n', много по-бързо е, тъй като не зачиства буфера!
}
~~~
  
**Важно допълнение**   
  
Винаги можете да напишете **"using namespace std"**, това ще ви спести да пишете std:: пред всяка функция от стандартната библиотека, но така и ще добавите абсолютно всичко, което се съдържа в самата библиотека. Вие не го виждате, но кодът се добавя, затова никъде другаде извън учебни цели няма да видите това написано. Затова и Ви моля да не го пишете. Създавайте си добри навици!

### Function Overloading  
---

За разлика от **C** в **C++** можем да имам функции с еднакви имена, но с различен прототип. Нека разгледаме с примери:

~~~.cpp

// Тези двете функции са еднакви за нашия компилатор и ще получим грешка, тъй като две функции не могат да се различват само и единствено по типа на връщане
int      do_smth(int a, int b);
double   do_smth(int a, int b);

// Задължително трябва да имаме промяна или в броя на аргументите или в тип им
int     do_smth(int b, char str[]);
int     do_smth();
~~~

### Стойности по подразбиране
---

Отново за разлика от **C**, който е измислен да е семпъл, в **C++** можем да направим още нещо интересно с параметрите на нашите функции, можем да им добавим стойност по подразбиране, но при определени условя:

1) Параметрите със стойност по подразбиране трябва **задължително** да са последни.
2) Ако напишем дефиницията на функцията някъде другате, в header файл или в клас, стойностт по подразбиране се пише само в декларацията на функцията, а не и в дефиницията. Това ще доведе до грешка!

~~~.cpp
// Пример

void my_func(int num, const char str[] name = "Pesho", const char final_name[] = "Peshov");

// Това е невалидна декларация на функция
void invalid_sytax(int num = 1, int num2);

int main(void)
{
    // извикване -> останалите два аргумента са със стойност по подразбиране
    my_func(1); 
}
~~~

### Тип bool 
---

В **C++** имаме вграден тип bool, който е с размер 1 byte и има само две стойност - true, false (истина или лъжа). Променливите от тип bool могат да работят с вградените логически оператори като: &&, ||, !, <, >, ==, != и т.н

~~~.cpp
#include <iostream>

int main(void)
{
    bool am_i_alive = 1; // подлежи на въпрос

    std::cout << am_i_alive;                     // ще изведе 1 на конзолата
    std::cout << std::boolalpha << am_i_alice;   // ще изведе true на конзолата 
}
~~~

### Псевдоними (Referances)
---
Референцията е чисто нова концепцият, тъй като само **C++** ни я предоставя. Синтаксисът и е следния:  

~~~
T& ref = <already defined variable of type T>
~~~
Може да си представите референцията, като опълномощено от вас лице. Тя има право да прави всичко от ваше има и да се разпорежда все едно е вас.

По-малко абстрактно казано, референцията е нов тип променлива, която си присвоява адреса на **вече съществуваща** друга променлива и веднъж присовена **НЕ** може да бъде променяна. Веднъж заключите ли я към дадена променлива не може да я промените. Оабаче всяка промяна по стойността на референцията директно променя и оригиналната променлива, тъй като референцията има същия адрес като оригиналната променлива.
**Референция НЕ може да няма стойност**, това води до undefined behaviour и dangling reference грешки. Когато искате да използвате референции **ВИНАГИ** се подсигурявате, че нещото което сочи ще надживее употребата на референцията иначе може да се окажете с променлива, която сочи зачистена памет, дали стекова дали динамична.

~~~.cpp

int& return_2()
{
    int a = 2;
    return a;
}

int main(void)
{
    int num = 1;      // има адрес 0xA
    int& ref = num;   // ref има също адрес 0xA

    ref = 2;
    std::cout << ref == num; // винаги ще връща 1

    // НЕВАЛИДНО, това е референция без стойност, няма да се компилира!
    int& ref;

    // НЕВАЛИДНО, това е dangling reference, тъй като a ще се освободи при приключване на функцията (стекова памет)
    int& ref = return_2();

    // НЕВАЛИДНО, няма псевдоним към псевдоним
    int&& ref_ref = ref;

    // НЕВАЛИДНО, не може да дефинираме масив от псевдоними
    int& ref_arr[10];
}

~~~

### Работа с динамична памет
---

#### Разлика между NULL и nullptr

В **C** за дефиниране на нулев указател използвахме макроса NULL, който има целочислена стойност равна на 0. В **C++**, обаче, има специална запазена дума, а именно **nullptr**. Това е единствената константа от тип nullptr_t и може да бъде преобразувана към булева стойност false, индикираща невалиден указател.

~~~.cpp
// Пример за разликата между nullptr и NULL

int foo(char* ptr) {...}
int bar(int val)   {...}

int main()
{
    foo(NULL);     // валидно
    bar(NULL);     // валидно

    foo(nullptr);  // валидно
    bar(nullptr);  // невалиднo, nullptr не може да се конвертира до int
}
~~~

#### Нови оператори new и delete

Най-съществената разлика, която ще срещнем е точно тук при заделянето на памет. Вместо добре познатите ни досега malloc/calloc/realloc/free, които ни връщаха void* (без free), в **C++** имаме операторът **new**, който ще ни служи за заделяне на памет и операторът **delete**, който ще ни служи за освобождаване на вече заделената памет. Самите оператори, отдолу използват malloc и free (те са техни обвивки), но затова ще говорим малко по-късно. 

Ще демонстрирам използването им в тези малки примери:

~~~.cpp
#include <stdexcept>

int main()
{
    int* number = allocate_no_value();
    *number = 10;
 
    int* number_with_value = allocate_with_value(10);
    int* arr = allocate_array(10);

    // Операторът за заделяне на памет трява да съпада с този за освобождаване
    // Заделяме един елемент --> delete
    // Заделяме масив        --> delete[]

    delete arr;
    delete number_with_value;
    delete[] arr; 
}

int* allocate_no_value()
{
    // заделяме памет с new. За сега nothrow остава мистерия...
    int* number = new(std::nothrow) int();
    if(!number)
    {
        std::cerr << "No free memory!";
        return nullptr;
    }

   return number;
}

int* allocate_with_value(int val)
{
    // заделяме памет с new и задаваме стойност в скобите
    int* number = new(std::nothrow) int(val);
    if(!number)
    {
        std::cerr << "No free memory!";
        return nullptr;
    }

    return number;
}

int* allocate_array(int size)
{
    // заделяме памет за масив със size елемента. Този път скобите са квадратни
    int* arr = new(std::nothrow) int[size];
    if(!number)
    {
        std::cerr << "No free memory!";
        return nullptr;
    }

    return arr;
}
~~~

### Изборен тип (Enumerations)
---

Енумерациите са нещо, което го има както в **C** така и в **C++**. Те представляват съставен тип данни или просто казано, те са тип данни, който в себе си съдържа фундаментални типове данни. В случая enum-ите съпоставят целочислена стойност на някакво име / наименувана константа / етикет

Енумерациите се инициализират неявно от нула, като растат със стъпка 1 ако не е оказано нещо друго, ето два примера:

~~~.cpp
enum colors
{
    BLUE,     // това ще има стойност 0
    RED,      // това ще има стойност 1
    WHITE,    // това ще има стойност 2
};

enum colors_2
{
    ORANGE,        // това ще има стойност 0
    BLACK   = 18,  // това ще има стойност 18
    RED,           // това ще има стойност 19
}
~~~

Ето една практическа имплементация на енумерация, която пази различни формати за запис. Тук се възползвам от неявното инициализиране, за да може последната стойност да пази броят на всички стойности в енумераципта.

~~~.cpp

enum format
{
    F_UNKNOWN = -1,

    F_PNG,
    F_BMP,
    F_JPG,
    F_PBM,
    F_PGM,

    F_FORMATS_CNT
};

static char formats_string[F_FORMATS_CNT] = { "PNG", "BMP", "JPG", "PBM", "PGM" };

void print_format(format f)
{
    assert(f != F_UNKNOWN);
    std::cout << format_string[(int)f];
}
~~~






