# Допълнение към курса по УП

### Задача 1 → Симулатор на процесорни инструкции

Ще симулираме работата на прост процесор, който управлява масив от регистри. Всеки регистър е цяло число, в което отделните битове служат като независими индикатори (флагове) за състоянието на хардуера.

Потребителят въвежда **цяло число** `N` (брой регистри). Заделете динамичен масив от тип `unsigned int` с размер `N` и го инициализирайте с нули.

Дефинирайте константи за флаговете:

```cpp
// Бит 0: готов за четене
const unsigned int FLAG_READY = 1 << 0;

// Бит 1: зает/обработва се
const unsigned int FLAG_BUSY = 1 << 1;

// Бит 2: възникнала грешка
const unsigned int FLAG_ERROR = 1 << 2;
```

Реализирайте функции, които променят състоянието на регистъра директно в паметта чрез **референция**:

- `void setFlag(unsigned int& reg, unsigned int mask)` → вдига съответния бит, използвайки побитово **ИЛИ** (`|`)
- `void clearFlag(unsigned int& reg, unsigned int mask)` → сваля съответния бит, използвайки побитово **И** (`&`) с инвертирана маска (`~`)

В `main` обходете масива и задайте случайни състояния на всеки регистър. Използвайте `rand() % 100`, за да определите състоянието:

- **Шанс за грешка (20%):** Използвайте `setFlag` с `FLAG_ERROR`
- **Шанс за работа (40%):** Използвайте `setFlag` с `FLAG_BUSY`
- **Шанс за готовност (40%):** Използвайте `setFlag` с `FLAG_READY` и се уверете, че регистърът **не е зает**

Дефинирайте тип за указател към функция (предикат), който приема стойността на регистъра и връща `bool`:

```cpp
typedef bool (*CheckFunc)(unsigned int);
```

Напишете функции за проверка:

1. `isBroken` → връща `true`, ако е вдигнат битът за грешка (`FLAG_ERROR`)
2. `isAvailable` → връща `true`, ако регистърът е готов (`READY`) **И** не е зает (`!BUSY`)

Нека потребителят да избере режим на работа (търсене на дефектни или свободни и готови регистри).

Извикайте универсална функция `processRegisters`, която приема масива, неговия размер и **указател към избраната функция за проверка**. Тя трябва да отпечата индексите на всички регистри, които отговарят на условието.

---

### Задача 2 → Система за сигурна обработка на данни

Ще разработите модул за нискостепенна обработка на информация. Целта е да се приложат побитови трансформации върху масив от данни, симулирайки процеси на криптиране и реорганизация на паметта.

Заделете динамичен масив от тип `unsigned char` с размер `N`. Напишете три функции, които модифицират подадения байт. Всяка функция трябва да демонстрира различна побитова операция:

- `encryptXOR` → прилага XOR с маска `0xAA` (`10101010`)
- `invertBits` → обръща всички битове на числото (използвайте оператора за побитово отрицание `~`)
- `swapNibbles` → разменя първите 4 бита със следващите 4 бита на байта (изисква `<<`, `>>` и `|`)

За да бъде системата гъвкава, дефинирайте тип за указател към функция. Функциите трябва да работят **директно върху оригиналните данни**.

```cpp
// Дефиниция на тип: функция, която не връща нищо, но променя байт през референция
typedef void (*TransformFunc)(unsigned char&);
```

Напишете функция `applyTransformation`, която служи като "двигател" на системата. Тя трябва да приема:

- Динамичния масив от байтове
- Размера на масива
- Указател към избраната трансформация (`TransformFunc`)

Функцията трябва да обходи масива и да приложи подадената трансформация върху всеки един елемент.

---

### Задача 3 → Динамичен архив с филтриране

Разполагате с масив от данни (напр. измервания от сензори). Трябва да филтрирате само "валидните" данни (тези, които отговарят на определено условие), да преместите тези данни в **нов масив с точен размер** и да ги сортирате.

Потребителят въвежда броя на елементите и запълва динамичния масив `int* data` с тях.

Дефинирайте тип `Predicate`:

```cpp
typedef bool (*Predicate)(int);
```

Напишете функции:

- `isPositive` → връща `true`, ако числото е по-голямо от 0
- `isEven` → връща `true`, ако числото е четно

Напишете функция `extractValidData`, която:

1. Приема оригиналния масив
2. Брои колко елемента отговарят на подадения `Predicate`
3. Заделя **нов масив** с точно този размер
4. Копира валидните елементи в него
5. **Освобождава** старата памет и пренасочва оригиналния указател към новия масив чрез референция (`int*& ptr`)

Дефинирайте тип `Comparator` за сравнение на две числа:

```cpp
typedef bool (*Comparator)(int, int);
```

Напишете функции `compareAsc` и `compareDesc`. След това реализирайте функция `sortArray`, която приема:

- Динамичния масив (вече преоразмерен)
- Новия му размер
- Указател към функция (`Comparator`)

Вътре в нея реализирайте обикновен алгоритъм за сортиране (например Bubble Sort), но вместо твърдо зададена проверка като `if (a > b)`, използвайте подадения компаратор, за да решите дали да размените два елемента.

В `main` създайте масив от указатели към функции, който съдържа вашите компаратори:

```cpp
Comparator myStrategies[] = { compareAsc, compareDesc };
```

Позволете на потребителя да избере режим (0 за възходящо, 1 за низходящо) и подайте съответния елемент от масива `myStrategies` на функцията `sortArray`.